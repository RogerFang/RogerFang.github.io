<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="线程,锁,Lock,AbstractQueuedSynchronizer," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.2" />






<meta name="description" content="概述队列同步器（AbstractQueuedSynchronizer，AQS），是用来构建锁或其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。
队列同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解：

锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面">
<meta property="og:type" content="article">
<meta property="og:title" content="Lock: 队列同步器AbstractQueuedSynchronizer">
<meta property="og:url" content="http://yoursite.com/2017/01/07/Lock-队列同步器/index.html">
<meta property="og:site_name" content="方龙的博客">
<meta property="og:description" content="概述队列同步器（AbstractQueuedSynchronizer，AQS），是用来构建锁或其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。
队列同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解：

锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面">
<meta property="og:updated_time" content="2017-01-15T14:42:11.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lock: 队列同步器AbstractQueuedSynchronizer">
<meta name="twitter:description" content="概述队列同步器（AbstractQueuedSynchronizer，AQS），是用来构建锁或其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。
队列同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解：

锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2017/01/07/Lock-队列同步器/"/>


  <title> Lock: 队列同步器AbstractQueuedSynchronizer | 方龙的博客 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?a1eb6dc312a93939356214ab5491901a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">方龙的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Lock: 队列同步器AbstractQueuedSynchronizer
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-07T23:11:15+08:00" content="2017-01-07">
              2017-01-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java-SE/" itemprop="url" rel="index">
                    <span itemprop="name">Java SE</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>队列同步器</strong>（AbstractQueuedSynchronizer，AQS），是用来构建<strong>锁</strong>或其他<strong>同步组件</strong>的基础框架，它使用了一个int成员变量表示<strong>同步状态</strong>，通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作。</p>
<p>队列同步器是实现锁（也可以是任意同步组件）的关键，<strong>在锁的实现中聚合同步器，利用同步器实现锁的语义</strong>。可以这样理解：</p>
<blockquote>
<p>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同<em>步状态管理</em>、<em>线程的排队</em>、<em>等待与唤醒</em>等底层操作。</p>
</blockquote>
<p>队列同步器的设计是<strong>基于模板方法模式</strong>的，使用时需要继承同步器并重写指定的方法，随后将同步器组合在自定义的同步组件中，并调用同步器提供的模板方法，这些模板方法会调用重写的方法。</p>
<blockquote>
<p>队列同步器的模板方法基本上分为3类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的线程情况。</p>
</blockquote>
<p>AQS的功能可以分为两类：<strong>独占</strong>功能和<strong>共享</strong>功能，它的所有子类中，要么实现并使用了它独占功能的API，要么使用了共享锁的功能，而不会同时使用两套API，即便是它最有名的子类ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别实现的两套API来实现的。s</p>
<h1 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h1><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p><strong>队列同步器依赖内部的同步队列（一个FIFO的双向队列）来完成同步状态的管理</strong>。</p>
<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），并将其加入同步队列，同时会阻塞当前线程；当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<blockquote>
<p>同步队列中的<strong>节点</strong>用来保存获取同步状态失败的<strong>线程引用</strong>、<strong>等待状态</strong>以及<strong>前驱节点和后继节点</strong>。</p>
</blockquote>
<p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点在获取同步状态成功时会将自己设置为首节点。</p>
<h2 id="独占式同步状态获取和释放"><a href="#独占式同步状态获取和释放" class="headerlink" title="独占式同步状态获取和释放"></a>独占式同步状态获取和释放</h2><p>通过调用<code>acquire(int arg)</code>方法<strong>独占式</strong>（同一时刻只有一个线程成功获取同步状态）地获取同步状态，该方法对<strong>中断不敏感</strong>，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Acquires in exclusive mode, ignoring interrupts.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码主要逻辑：</p>
<ol>
<li><strong>同步状态获取</strong><br> 首先调用<strong>自定义同步器实现</strong>的<code>tryAcquire(int arg)</code>方法，<em>该方法保证线程安全的获取同步状态</em>。</li>
<li><strong>节点构造</strong><br> 如果同步状态获取失败，则构造同步节点，独占式的节点。</li>
<li><strong>加入同步队列</strong><br> 节点构造完成后，通过<code>addWaiter(Node noe)</code>方法加入到同步队列的尾部。</li>
<li><strong>在同步队列中自旋</strong><br> 最后调用<code>acquireQueued(Node node, int arg)</code>方法，使得该节点以“死循环”的方式获取同步状态。</li>
</ol>
<h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates and enqueues node for current thread and given mode.</div><div class="line"> */<span class="function">k</span></div><div class="line"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> &#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    <span class="comment">// 快速尝试在尾部添加</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步器提供了一个基于<strong>CAS</strong>的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>。</p>
<blockquote>
<p>如果使用线程不安全的<code>LinkedList</code>来维护节点之间的关系，那么并发的时候，LinkedList将难以保证Node的正确添加。</p>
</blockquote>
<h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><p><code>enq(Node noe)</code>方法中，同步器通过“<strong>死循环</strong>”来保证节点的正确添加，在死循环中只有通过CAS将节点设置为尾节点之后，当前线程才能从该方法返回，否则当前线程不断尝试。</p>
<blockquote>
<p><code>enq</code>方法将并发添加节点的请求通过CAS变得串行化了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts node into queue, initializing if necessary.</div><div class="line"> * 由于这里存在多线程并发问题，使用死循环保证node能够添加到链表中，因此enq本身是线程安全的</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>节点进入同步队列后，就进入了一个自旋的过程，每个节点（线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>shouldParkAfterFailedAcquire()</code>就是靠前驱节点判断当前线程是否应该被阻塞，如果前驱节点为SIGNAL，则阻塞当前线程；如果前继节点处于CANCELLED状态，则删除节点重新构造队列；前驱节点状态为0（默认进入队列即为0）或PROPAGATE，设前驱节点的状态为SIGNAL，当前线程在下一轮循环进入该方法将返回true，进入阻塞状态。</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>当线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态。该方法会唤醒头结点的后继节点线程，<code>unparkSuccessor(Node node)</code>方法使用LockSupport来唤醒处于等待状态的线程。<br>被唤醒的线程将继续在acquireQueued的死循环中进行锁竞争，直到成功获取锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="共享式同步状态获取和释放"><a href="#共享式同步状态获取和释放" class="headerlink" title="共享式同步状态获取和释放"></a>共享式同步状态获取和释放</h2><blockquote>
<p>共享式获取与独占式获取最主要的区别在于同一个时刻能否有多个线程同时获取到同步状态。</p>
</blockquote>
<p>以文件读写为例，写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p>
<h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><p>通过调用队列同步器的<code>acquireShared(int arg)</code>方法可以共享式地获取同步状态。</p>
<p><code>tryAcquireShared(int arg)</code>方法的返回值说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. a negative value on failure;</div><div class="line">2. zero if acquisition in shared mode succeeded but no subsequent shared-mode acquire can succeed;</div><div class="line">3. and a positive value if acquisition in shared mode succeeded and subsequent shared-mode acquires might also succeed, in which case a subsequent waiting thread must check availability.</div></pre></td></tr></table></figure></p>
<p>在<code>doAcquireShared(int arg)</code>方法中将共享式节点加入到同步队列中，并进入自旋的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">	<span class="comment">// 将当前线程包装为一个共享类型的节点</span></div><div class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head) &#123;</div><div class="line">            	<span class="comment">// 如果新建节点的前一个节点，就是Head，说明当前节点是AQS队列中等待获取锁的第一个节点。</span></div><div class="line">				<span class="comment">// 按照FIFO的原则，可以直接尝试获取锁。</span></div><div class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                	<span class="comment">// 成功获取锁，需要将当前节点设置为AQS队列中的第一个节点。</span></div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    <span class="keyword">if</span> (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>setHeadAndPropagate(Node node, int propagate)</code>方法首先是更换了头结点，然后获取当前节点的后继节点，如果同样是“shared”类型的，再做一次“releaseShared”操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets head of queue, and checks if successor may be waiting</div><div class="line"> * in shared mode, if so propagating if either propagate &gt; 0 or</div><div class="line"> * PROPAGATE status was set.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> node the node</div><div class="line"> * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</div><div class="line">    Node h = head; <span class="comment">// Record old head for check below</span></div><div class="line">    setHead(node);</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Try to signal next queued node if:</div><div class="line">     *   Propagation was indicated by caller,</div><div class="line">     *     or was recorded (as h.waitStatus either before</div><div class="line">     *     or after setHead) by a previous operation</div><div class="line">     *     (note: this uses sign-check of waitStatus because</div><div class="line">     *      PROPAGATE status may transition to SIGNAL.)</div><div class="line">     * and</div><div class="line">     *   The next node is waiting in shared mode,</div><div class="line">     *     or we don't know, because it appears null</div><div class="line">     *</div><div class="line">     * The conservatism in both of these checks may cause</div><div class="line">     * unnecessary wake-ups, but only when there are multiple</div><div class="line">     * racing acquires/releases, so most need signals now or soon</div><div class="line">     * anyway.</div><div class="line">     * 尝试唤醒后继节点：</div><div class="line">     *		propagate &gt; 0说明许可还有能够继续被线程acquire;</div><div class="line">     * 		或者 之前的head被设置为PROPAGATE(PROPAGATE可以被转换为SIGNAL)说明需要往后传递;</div><div class="line">     * 		或者为null</div><div class="line">     * 并且 后继节点是共享模式或者为null。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</div><div class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</div><div class="line">        Node s = node.next;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</div><div class="line">        	<span class="comment">// 唤醒后继节点</span></div><div class="line">            doReleaseShared();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><p>通过调用<code>releaseShared(int arg)</code>方法可以释放同步状态，在释放同步状态之后，将会唤醒后续处于等待状态的节点。</p>
<blockquote>
<p>对于能够支持多个线程同时访问的并发组件（如Semaphore），它和独占式的主要区别在于<code>tryReleasedShared(int arg)</code>方法必须确保同步状态线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">        doReleaseShared();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Release action for shared mode -- signals successor and ensures</div><div class="line"> * propagation. (Note: For exclusive mode, release just amounts</div><div class="line"> * to calling unparkSuccessor of head if it needs signal.)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h2><p>通过调用同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到了则返回true，否则返回false。</p>
<blockquote>
<p>该方法提供了传统Java同步操作（如synchronized关键字）所不具备的特性。</p>
</blockquote>
<p><code>doAcquireNanos(int arg)</code>方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似。但是在同步状态获取失败的处理上有所不同，如果当前线程获取同步状态失败，则判断是否超时，如果没有超时，重新计算超时间隔，然后使当前线程等待。</p>
<p>共享式超时获取同步状态的过程与之类似<code>doAcquireSharedNanos(int arg, long nanosTimeout)</code>。</p>
<hr>
<p>相关：<br><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="external">http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer</a><br><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer" target="_blank" rel="external">http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/线程/" rel="tag">#线程</a>
          
            <a href="/tags/锁/" rel="tag">#锁</a>
          
            <a href="/tags/Lock/" rel="tag">#Lock</a>
          
            <a href="/tags/AbstractQueuedSynchronizer/" rel="tag">#AbstractQueuedSynchronizer</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/07/Lock-概述/" rel="next" title="Lock: 概述">
                <i class="fa fa-chevron-left"></i> Lock: 概述
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/15/Lock-重入锁ReentrantLock/" rel="prev" title="Lock: 重入锁ReentrantLock">
                Lock: 重入锁ReentrantLock <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="方龙" />
          <p class="site-author-name" itemprop="name">方龙</p>
          <p class="site-description motion-element" itemprop="description">码路漫漫，且行且珍惜</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">94</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">109</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/RogerFang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/a-mu-mu-art" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列同步器的实现分析"><span class="nav-number">2.</span> <span class="nav-text">队列同步器的实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#同步队列"><span class="nav-number">2.1.</span> <span class="nav-text">同步队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#独占式同步状态获取和释放"><span class="nav-number">2.2.</span> <span class="nav-text">独占式同步状态获取和释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acquire"><span class="nav-number">2.2.1.</span> <span class="nav-text">acquire</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addWaiter"><span class="nav-number">2.2.2.</span> <span class="nav-text">addWaiter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enq"><span class="nav-number">2.2.3.</span> <span class="nav-text">enq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acquireQueued"><span class="nav-number">2.2.4.</span> <span class="nav-text">acquireQueued</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#release"><span class="nav-number">2.2.5.</span> <span class="nav-text">release</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享式同步状态获取和释放"><span class="nav-number">2.3.</span> <span class="nav-text">共享式同步状态获取和释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acquireShared"><span class="nav-number">2.3.1.</span> <span class="nav-text">acquireShared</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#releaseShared"><span class="nav-number">2.3.2.</span> <span class="nav-text">releaseShared</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#独占式超时获取同步状态"><span class="nav-number">2.4.</span> <span class="nav-text">独占式超时获取同步状态</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">方龙</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  



  




  
  

  

  

  

  


</body>
</html>
