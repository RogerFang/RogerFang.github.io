---
title: Java 反射原理解析
date: 2016-12-31 22:09:50
categories:
- Java SE
tags:
- 反射
---

> Java的反射机制允许我们动态的调用某个对象的方法/构造函数、获取某个对象的属性等，而无需在编码时确定调用的对象。

# Method
> JDK中`Method.invoke()`实际上并不是自己实现的反射调用逻辑，而是委托给`sun.reflect.MethodAccessor`来处理的。

首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为`root`，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。

JDK 1.8中`Method.invoke()`源码
```java
public final class Method extends Executable {
    private volatile MethodAccessor methodAccessor;
    private Method root;

    @CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class<?> caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    }

    private MethodAccessor acquireMethodAccessor() {
        // First check to see if one has been created yet, and take it
        // if so
        MethodAccessor tmp = null;
        if (root != null) tmp = root.getMethodAccessor();
        if (tmp != null) {
            methodAccessor = tmp;
        } else {
            // Otherwise fabricate one and propagate it up to the root
            tmp = reflectionFactory.newMethodAccessor(this);
            setMethodAccessor(tmp);
        }

        return tmp;
    }
}
```

# MethodAccessor
`MethodAccessor`的实例是由`sun.reflect.ReflectionFactory`创建的。
```java
public class ReflectionFactory{

	private static boolean noInflation = false;

	public MethodAccessor newMethodAccessor(Method var1) {
        checkInitted();
        if(noInflation && !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) {
            return (new MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());
        } else {
            NativeMethodAccessorImpl var2 = new NativeMethodAccessorImpl(var1);
            DelegatingMethodAccessorImpl var3 = new DelegatingMethodAccessorImpl(var2);
            var2.setParent(var3);
            return var3;
        }
    }
}
```
实际的MethodAccessor实现有两个版本，一个是Java实现的，另一个是native code实现的。
Java实现的版本在初始化时需要较多时间，但长久来说性能较好；
native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。

> 为了权衡两个版本的性能，Sun的JDK使用了“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版。

**invoke方法调用过程**
![](/images/javase/java-reflection-method-invoke.png)
* * *
感谢：
http://www.sczyh30.com/posts/Java/java-reflection-2/