---
title: 设计模式概述和面向对象的设计原则
date: 2017-06-04 19:00:42
categories:
- 设计模式
tags:
- 设计模式
---

使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。


# 分类
1. **创建型模式**，共 5 种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
2. **结构型模式**，共 7 种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
3. **行为型模式**，共 11 种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

# 面向对象的设计原则
## 单一原则 SRP
> 单一原则(Single Responsibility Principle, SRP):一个类只负责一个功能领域中的相应职责。高内聚、低耦合。

一个类（大到模块，小到方法）承担的责任越多，被复用的可能性越小。多个职责耦合在一起，当其中一个变化时，可能会影响到其他职责的执行。

## 开闭原则 OCP
> 开闭原则(Open Close Principle):对扩展开放，对修改关闭。抽象化是开闭原则的关键。是面向对象设计的**目标**。

在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果。

## 里氏代换原则 LSP
> 里氏代换原则(Liskov Substitution Principle, LSP):所有引用基类对象的地方能够透明地使用其子类对象，反之不成立。

里氏代换原则是**继承复用**的基石。只有当子类可以替换掉基类，软件单位的功能不会受到影响时，基类才能真正被复用，而子类也才能够在基类的基础上增加新的行为。

里氏代换原则是实现开闭原则的重要方式之一，在程序中尽量使用基类类型进行定义，而在运行时再确定其子类类型。

## 依赖倒转原则 DIP
> 依赖倒转原则(Dependency Inversion Principle, DIP):要依赖于抽象，不要依赖于具体。(要针对接口编程，不要针对实现编程。)

实现“开-闭”原则的关键是抽象化，并且从抽象化导出具体化实现。“开-闭”原则是面向对象设计的目标，依赖倒转原则是面向对象设计的主要机制。

**针对接口编程**是说，应该使用Java接口或Java抽象类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。

引入抽象后，系统具有很好的灵活性，程序中尽量使用抽象层进行编程，将具体实现类写在配置文件中，这样可以在不修改源码的情况下来扩展系统功能。

## 接口隔离原则 ISP
> 接口隔离原则(Interface Segregation, ISP):使用多个专门的接口比使用单一的总接口要好。

每个接口应该承担一种相对独立的角色，要注意控制接口的粒度，太小导致接口泛滥不利于维护，太大则违背接口隔离原则灵活性差。

## 迪米特法则 LoD
> 迪米特法则(Law of Demeter)又称最少知道原则，就是说，一个对象应当和其他对象尽可能少地发生相互作用，使得系统功能模块相对独立。

降低系统的耦合度，一个对象的改变不会给其他对象带来影响，通过引入一个合理的**第三者**来降低现有对象之间的耦合度。

## 合成/聚合复用原则 CRP
> 合成复用原则(Composite Reuse Principle, CRP):要尽量使用合成/聚合，而不是使用继承来达到复用的目的。

合成/聚合复用原则是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。

“**白箱复用**”：通过继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，如果基类发生改变，那么子类的实现不得不发生改变。从基类继承的实现是静态的，无法再运行时发生改变，没有足够的灵活性。

“**黑箱复用**”：组合/聚合关系可以通过依赖对象完成相应的功能，依赖对象的实现细节对于新对象是不可兼得，其耦合程度相对较低，可以在运行时动态引用同类型的其他实现。

