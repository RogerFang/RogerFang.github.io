---
title: 'JVM: Java虚拟机运行时数据区域'
date: 2017-01-05 14:32:43
categories:
- JVM
tags:
- JVM
- 运行时数据区
---

> Java与C/C\+\+之间有一堵由**动态内存分配**和**垃圾收集技术**所围成的“高墙”。

Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。
![](/images/jvm/jvm-runtime-data-area.png)

# 程序计数器
程序计数器（Program Counter Register）是一块**线程私有**的内存空间，可以看作是**当前线程**所执行的字节码的行号指示器。

由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核只会执行一条线程中的指令。因此，**为了线程切换后能恢复到正确的执行位置**，每个线程都需要一个独立的程序计数器。

> 解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

# Java虚拟机栈
Java虚拟机栈（VM Stack）也是**线程私有**的，它的生命周期与线程相同。虚拟机栈描述的是**方法执行**的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储*局部变量表*、*操作数栈*、*动态连接*、*方法出口*等信息。
![](/images/jvm/vm-stack-memory-model.png)

> 具体栈帧结构可以参见：[字节码执行引擎](https://rogerfang.github.io/2017/01/04/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-1-%E6%A6%82%E8%BF%B0/)

Java虚拟机规范对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常。当扩展虚拟机栈动态扩展时，如果无法申请到足够的内存，将会抛出`OutOfMemoryError`异常。

# 本地方法栈
本地方法栈（Native Method Stack）与虚拟机栈类似，只不过虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
> HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。

和虚拟机栈一样，也会抛出`StackOverflowError`和`OutOfMemoryError`异常。

# Java堆
Java堆（Heap）是Java虚拟机所管理的内存中最大的一块，被所有**线程共享**，虚拟机启动时创建。
> 几乎所有的对象实例（以及数组）都在这里分配内存。但是随着JIT编译器的发展和逃逸分析技术成熟，栈上分配、标量替换优化技术会导致一些变化，也就变得没那么绝对。

Java堆是垃圾收集器管理的主要区域，很多时候也被称为“**GC堆**”。
如果堆中没有内存来完成实例分配，并且堆也无法再扩展时，将会抛出`OutOfMemoryError`异常。

# 方法区
方法区（Method Area）也是**线程共享**的内存区域，它用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、*即时编译器编译后的代码*等数据。

Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名Non-Heap“非堆”，目的是与Java堆区分开。
>这个区域的内存回收比较少见，主要是针对**常量池的回收**和对**类型的卸载**。

## 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，**用于存放编译期生成的各种字面量和符号引用**，这部分内容在类加载后进入方法区的运行时常量池中存放。

除了保存Class文件中描述的符号引用外，还会把翻译出来的**直接引用**也存储在运行时常量池中。

> 运行时常量池 相对于 Class文件常量池的一个重要特征是具备动态性，也就是运行期间也可能将新的常量放入池中，例如String类的`intern()`方法。

当常量池无法再申请到内存时，也会抛出`OutOfMemoryError`异常。

# 直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

在JDK 1.4中新加入的**NIO**类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O模式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样在一些场景能提高性能，因为避免了在Java堆和Native堆中来回赋值数据。
