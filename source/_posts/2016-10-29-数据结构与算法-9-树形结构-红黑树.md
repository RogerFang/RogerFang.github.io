---
title: '数据结构与算法(9): 树形结构- 红黑树'
date: 2016-10-29 17:46:38
categories:
- 数据结构与算法
tags:
- 数据结构
- 树形结构
- 二叉树
- 二叉查找树
- 2-3树
- 红黑树
---

# 介绍
&emsp;&emsp;红黑二叉查找树（红黑树）：基本思想是用标准的二叉查找树（完全由2-节点构成）和一些额外的信息（替换3-节点）来表示2-3树。
&emsp;&emsp;红链接：将两个2-节点连接起来构成一个3-节点。
&emsp;&emsp;黑链接：是2-3树中的普通链接。

红黑树另一种定义是含有红黑链接并满足下列条件的二叉查找树：
&emsp;&emsp;1. 红链接均为左链接；
&emsp;&emsp;2. 没有任何一个节点同时有两条红链接相连；
&emsp;&emsp;3. 该树是**完美黑色平衡的**，即任意空链接到根节点的路径上的黑链接数量相同。

颜色表示，为了方便做出以下规定：
&emsp;&emsp;1. 根节点为黑色；
&emsp;&emsp;2. 空节点为黑色。

# 操作
## 旋转
&emsp;&emsp;在进行某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前都可以通过旋转来修复。红黑树的旋转只有两种：顺时针旋转（右旋转）和逆时针旋转（左旋转）。
```java
	/**
     * 左旋转：红色右链接 -> 红色左链接
     *
     * @param node
     * @return
     */
    private Node<T> rotateToLeft(Node<T> node) {
        Node<T> x = node.right;
        node.right = x.left;
        x.left = node;
        x.color = node.color;
        node.color = RED;
        return x;
    }
    
    /**
     * 右旋转： 红色左链接 -> 红色右链接
     *
     * @param node
     * @return
     */
    private Node<T> rotateToRight(Node<T> node) {
        Node<T> x = node.left;
        node.left = x.right;
        x.right = node;
        x.color = node.color;
        node.color = RED;
        return x;
    }
```
![](/images/tree/rb-tree-rotate.png)
## 插入
&emsp;&emsp;在2-3树中，我们将新插入的节点与树的底部节点合并，然后再做调整。为了表示合并，我们将新插入的节点均设为红色，表示与底部节点相连接。然而插入后，新的红节点可能会违反我们的规定，因此需要在回溯的时候进行调整。
1. **情况一：红色右链接**
&emsp;&emsp;当我们发现某个节点的左儿子是黑色但右儿子是红色时，我们要将右边的红色链接转到左边来。
![](/images/tree/rb-tree-insert-right-red.png)

2. **情况二：分解4-节点**
&emsp;&emsp;当左儿子和右儿子都是红色时，就代表着一个4-节点，为此我们可以直接将其反色来分解它。
![](/images/tree/rb-tree-insert-left-right-red.png)

3. **情况三：连续红色左链接**
&emsp;&emsp;当出现连续的红色左链接时，需要经过一次右旋转变成一个4-节点，再进行一次反色分解它。
![](/images/tree/rb-tree-insert-continue-red.png)

```java
	/**
     * 插入实现
     */
	private Node<T> insert(T ele, Node<T> tree){
        if (tree == null){
            return new Node<>(ele, RED);
        }

        int cmpResult = ele.compareTo(tree.element);
        if (cmpResult < 0){
            tree.left = insert(ele, tree.left);
        }else if (cmpResult > 0){
            tree.right = insert(ele, tree.right);
        }else {
            // duplicate; do nothing
        }

        // check balance
        if (isRed(tree.right) && !isRed(tree.left)){
            // 情况一：红色右链接
            tree = rotateToLeft(tree);
        }
        if (isRed(tree.left) && isRed(tree.left.left)){ // 该步在下一步flipColors之前进行校验
            // 情况三：连续红色左节点, 进行一次右旋转变成情况二4-节点
            tree = rotateToRight(tree);
        }
        if (isRed(tree.left) && isRed(tree.right)){
            // 情况二：分解4-节点
            tree = filpColors(tree);
        }

        return tree;
    }
```

感谢:https://riteme.github.io/blog/2016-3-12/2-3-tree-and-red-black-tree.html#_5