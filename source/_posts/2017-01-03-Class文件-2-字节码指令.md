---
title: 'Class文件(2): 字节码指令'
date: 2017-01-03 18:39:09
categories:
- JVM
tags:
- JVM
- 编译
- Class文件
---

Java虚拟机字节码指令：由1个字节长度的**操作码**（代表着某种特定操作含义的数字），以及跟随其后的0至多个**操作数**（Operands，此操作所需的参数）而构成。
> 再次强调Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都包含操作数，而只有一个操作码。

1. 指令的操作码长度为1个字节，意味着指令集的操作码总数不能超过256条。
2. Class文件格式放弃了编译后代码的**操作数长度对齐**。
当虚拟机处理超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构。如一个16位长度的无符号整数需要使用两个字节存储起来。
> 这种操作会在某种程度上导致解释器执行字节码时损失一些性能，优势是省略了很多填充和间隔符。

# 字节码指令与数据类型
在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的的数据类型信息。
操作码助记符都有特殊的字符来表明专门为哪种数据类型服务：`i`代表int类型的数据操作，`l`代表long，`s`代表short，`b`代表byte，`c`代表char，`f`代表float，`d`代表double，`a`代表reference。

一些操作指令（int类型指令）如：`iload`,`istore`,`iinc`,`iadd`,`isub`,`imul`,`idiv`,`ireturn`。

注意：编译器会在编译期或运行期将byte和short类型的数据**带符号扩展**（Sign-Extend）为相应的int类型数据，将boolean和char类型数据**零位扩展**（Zero-Extend）为相应的类型数据。

# 加载和存储指令
加载和存储指令用于将数据在栈帧中的**局部变量表**和**操作数栈**之间来回传输。

局部变量加载到操作数栈：`iload`、`iload_<n>`等，`n`代表指令隐含的操作数。
操作数栈存储到局部变量表：`istore`、`istore_n`等。

# 运算指令
运算指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
例如：
加法指令：`iadd`、`fadd`。
减法指令：`isub`、`fsub`。
求余指令：`irem`、`frem`。
局部变量自增指令：`iinc`。
按位或指令：`ior`、`lor`。
比较指令：`dcmpg`、`fcmpg`。

# 类型转换指令
类型转换指令可以将两种不同的数值类型进行相互转换。

Java虚拟机直接支持宽化类型转化（无需显示的转换指令）：
* int类型到long、float或double类型；
* long类型到float、double类型；
* float类型到double类型。

在处理窄化类型转化时，需要显示地使用转换指令：`i2b`、`i2c`、`i2s`、`l2i`、`f2i`、`f2l`、`d2i`、`d2l`和`d2f`。
窄化处理可能发生上限溢出、下限溢出和精度丢失等情况。
> Java虚拟机规范中规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

# 对象创建与访问指令
虽然累实例和数组都是对象，但是JVM对类实例和数组的创建和操作使用了不同的字节码指令。

* 创建类实例的指令：`new`。
* 创建数组的指令：`newarray`、`anewarray`、`multianewarray`。
* 访问类变量和实例变量的指令：`getfield`、`putfield`、`getstatic`、`putstatic`。
* 把一个数组元素加载到操作数栈的指令：`baload`、`caload`、`saload`、`iaload`、`laload`、`faload`、`daload`、`aaload`。
* 把一个操作数栈的值存储到数组元素中的指令：`bastore`、`castore` ...
* 取数组长度的指令：`arraylength`。
* 检查类实例类型的指令：`instanceof`、`checkcast`。

# 操作数栈管理指令
将操作数栈的栈顶一个或两个元素出栈：`pop`、`pop2`。
复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：`dup`、`dup2`、`dup_x1`、`dup2_x1`、`dup_x2`、`dup2_x2`。
将栈最顶端的两个数值互换：`swap`。

# 控制转移指令
控制转移指令可以让JVM有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序。

* 条件分支
`ifeq`、`iflt`、`ifle`、`ifne`、`ifgt`、`ifge`、`ifnull`、`ifnonnull`、`if_icmpeq`、`if_icmpne`、`if_icmplt`、`if_icmple`、`if_acmpeq`和`if_acmpne`。
* 复合条件分支
`tableswitch`、`lookupswitch`。
* 无条件分支
`goto`、`goto_w`、`jsr`、`jsr_w`、`ret`。

# 方法调用和返回指令
方法调用（分派、执行过程）与数据类型无关：
* `invokevirtual`：用于调用对象的实例方法，根据对象的实际类型进行分派（虚分派）。
* `invokeinterface`：用于调用接口方法，会在运行时搜索一个实现了接口方法的对象，找出适合的方法进行调用。
* `invokespecial`：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
* `invokestatic`：用于调用类方法。
* `invokedynamic`：用于在运行时动态解析出**调用点限定符**所引用的方法，并执行该方法。
> 前面4种调用指令的分派逻辑都固化在JVM内部，`invokedynamic`指令的分派逻辑是由用户所设定的引导方法决定的。


方法返回指令与数据类型相关，根据返回值的类型区分：`ireturn`（返回值是boolean、byte、char、short和int类型）、`lreturn`、`freturn`、`dreturn`和`areturn`；还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。

# 异常处理指令
Java程序中显示抛出异常的操作（throw语句）都是由`athrow`指令来实现的。

Java虚拟机规范还规定了许多**运行时异常**会在其他Java虚拟机指令检测到异常状况时**自动抛出**。

而在JVM中处理异常语句（catch语句，受查异常）不是由字节码指令来实现的，而是采用**异常表**来完成的（上一篇博客中的Code属性有介绍过）。

# 同步指令
Java虚拟机可以支持**方法级**的同步和**方法内部**的一段指令序列的同步，这两种同步结构都使用`管程`（Monitor）来支持的。

## 方法级的同步
方法级的同步是**隐式的**，不需要通过字节码指令来控制，它实现在方法调用和返回操作之中。

虚拟机可以从方法表结构中的`ACC_SYNCHRONIZED`访问标志得知是否声明为同步。
如果设置了，执行线程需要成功持有**管程**，然后才能执行方法。

## 方法内部的指令序列同步
同步一段指令集序列通常是由Java语言中的`synchronized`语句块来表示的，JVM指令集中有`monitorenter`和`monitorexit`两条指令来支持synchronized关键字的语义。
> 正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作。

编译器必须确保无论方法通过何种方式完成，方法中调用过的`monitorenter`指令都必须执行器对应的`monitorexit`指令，无论是正常结束还是异常结束。
