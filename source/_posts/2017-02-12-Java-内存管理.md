---
title: Java 内存管理
date: 2017-02-12 15:54:43
categories:
- JVM
---

# 内存管理
Java 的内存管理就是对象的分配和释放问题。

**分配** ：内存的分配是由程序完成的，程序员需要通过关键字`new`为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。

**释放** ：对象的释放是由**垃圾回收机制**决定和执行的，这样做确实简化了程序员的工作。但同时，它也加重了 JVM 的工作。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。

# 内存泄漏
在 Java 中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：
* 首先，这些**对象是可达的**，即在有向图中，存在通路可以与其相连（也就是说仍存在该内存对象的引用）；
* 其次，这些**对象是无用的**，即程序以后不会再使用这些对象。
如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。

# 内存分配策略
几条普遍的内存分配规则：
* 对象优先在Eden分配：大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配的时候，虚拟机将发起一次Minor GC。
* 大对象直接进入老年代：所谓大对象指的是需要大量连续内存空间的Java对象，最典型的的大对象就是那种很长的字符串及数组。
* 长期存活的对象将进入老年代：虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden每熬过一次Minor GC，年龄增加1，当年龄增加到一定成都，就会晋升到老年代中。

# 垃圾回收机制
垃圾回收是一种**动态存储管理**技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。

垃圾收集器是自动运行的，一般情况下，无需显示的请求垃圾收集器，程序运行时，垃圾收集器会不时检查对象的各个引用，并回收无引用对象所占用的空间。调用System类中的静态方法 gc() 可以运行垃圾收集器，但并不能保证立即回收指定对象。

具体请看：[JVM: 垃圾回收机制](https://rogerfang.github.io/2017/01/05/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)

