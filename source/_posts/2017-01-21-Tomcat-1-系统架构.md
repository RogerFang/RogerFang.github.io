---
title: 'Tomcat(1): 系统架构'
date: 2017-01-21 20:07:50
categories:
- tomcat
---

# 系统架构
![Tomcat系统架构](/images/tomcat/tomcat-system-architecture.png)

Tomcat的核心组件有两个：**Connector（连接器）**和**Container（容器）**。

# Server
**Server**：是Tomcat的顶级容器，对外提供一个接口访问Service，对内负责管理维护Service集合，维护Service集合又包括管理Service的生命周期、寻找一个请求的Service、结束一个Service等。

Server使用一个数组来管理Service的，每添加一个Service就把原来的Service拷贝到一个新的数组中，再把新的Service放入Service数组中。

`org.apache.catalina.Server`接口的标准实现类是`org.apache.catalina.core.StandardServer`。
```java
public interface Server extends Lifecycle

public final class StandardServer extends LifecycleMBeanBase implements Server
```

```java
/**
 * The set of Services associated with this Server.
 */
private Service services[] = new Service[0];
private final Object servicesLock = new Object();

/**
 * Add a new Service to the set of defined Services.
 *
 * @param service The Service to be added
 */
@Override
public void addService(Service service) {

    service.setServer(this);

    synchronized (servicesLock) {
        Service results[] = new Service[services.length + 1];
        System.arraycopy(services, 0, results, 0, services.length);
        results[services.length] = service;
        services = results;

        if (getState().isAvailable()) {
            try {
                service.start();
            } catch (LifecycleException e) {
                // Ignore
            }
        }

        // Report this property change to interested listeners
        support.firePropertyChange("service", null, service);
    }

}
```

# Service
Service是Tomcat提供对外服务的组件，用于关联Connector和Container，一个Service可以由 **多个** Connector + **一个** Container 构成。
`org.apache.catalina.Service`接口的标准实现类是`org.apache.catalina.core.StandardService`。
```java
public interface Service extends Lifecycle

public class StandardService extends LifecycleMBeanBase implements Service
```
## setContainer()
Service中的`setContainer()`方法的主要任务是，设置一个Container容器来处理一个或者多个Connector传送过来的请求。首先判断当前的Service是否已经关联了Container容器，如果已经关联了就去除原来的关联并与新的Container容器关联，新的Container容器开始新的生命周期，如果原来的Container容器已经启动则停止掉，最后把这个过程通知给感兴趣的事件监听程序。
```java
@Override
public void setContainer(Engine engine) {
    Engine oldEngine = this.engine;
    if (oldEngine != null) {
        oldEngine.setService(null);
    }
    this.engine = engine;
    if (this.engine != null) {
        this.engine.setService(this);
    }
    if (getState().isAvailable()) {
        if (this.engine != null) {
            try {
                this.engine.start();
            } catch (LifecycleException e) {
                log.warn(sm.getString("standardService.engine.startFailed"), e);
            }
        }
        // Restart MapperListener to pick up new engine.
        try {
            mapperListener.stop();
        } catch (LifecycleException e) {
            log.warn(sm.getString("standardService.mapperListener.stopFailed"), e);
        }
        try {
            mapperListener.start();
        } catch (LifecycleException e) {
            log.warn(sm.getString("standardService.mapperListener.startFailed"), e);
        }
        if (oldEngine != null) {
            try {
                oldEngine.stop();
            } catch (LifecycleException e) {
                log.warn(sm.getString("standardService.engine.stopFailed"), e);
            }
        }
    }

    // Report this property change to interested listeners
    support.firePropertyChange("container", oldEngine, this.engine);
}
```
## addConnector()
Service的`addConnector()`方法的主要任务是，设置connector与container和service的关联关系，然后让connector开始新的生命周期，最后通知感兴趣的事件监听程序。
```java
/**
 * Add a new Connector to the set of defined Connectors, and associate it
 * with this Service's Container.
 *
 * @param connector The Connector to be added
 */
@Override
public void addConnector(Connector connector) {

    synchronized (connectorsLock) {
        connector.setService(this);
        Connector results[] = new Connector[connectors.length + 1];
        System.arraycopy(connectors, 0, results, 0, connectors.length);
        results[connectors.length] = connector;
        connectors = results;

        if (getState().isAvailable()) {
            try {
                connector.start();
            } catch (LifecycleException e) {
                log.error(sm.getString(
                        "standardService.connector.startFailed",
                        connector), e);
            }
        }

        // Report this property change to interested listeners
        support.firePropertyChange("connector", null, connector);
    }

}
```

# Connector
**Connector**：连接器，负责接收请求并把请求交给Container。
主要任务是负责接收浏览器的发过来的 HTTP 请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后把 Request 和 Response 交给Container组件去处理。


# Container
**Container**：容器，主要装的是具体处理请求的组件。
Container 是容器的父接口，所有子容器都必须实现这个接口，Container 容器的设计用的是典型的责任链的设计模式，它有四个子容器组件构成，分别是：**Engine**、**Host**（虚拟主机）、**Context**（所属的Web应用）、**Wrapper**（针对每个具体的Servlet），它们是父子关系。


# Lifecycle接口
Tomcat 中组件的生命周期是通过 Lifecycle 接口来控制的，组件只要继承这个接口并实现其中的方法就可以统一被拥有它的组件控制了。

Tomcat中顶级容器管理着Service的生命周期，Service容器又是Connector和Container的父容器，所以这两个组件的生命周期是由Service管理的，Container也有子容器，所以管理着这些子容器的生命周期。这样，只要所有组件都实现了Lifecycle接口，从顶层容器Server开始，就可以控制所有容器的生命周期了。
> Lifecycle接口中定义了很多状态，在api中详细说明了调用不同方法后的状态转变。


* * *
感谢：
http://blog.csdn.net/u011116672/article/details/50993980
