---
title: Linux网络I/O模型
date: 2017-02-25 10:54:17
categories:
- Linux
tags:
- IO
---

参考：[同步、异步、阻塞和非阻塞](https://rogerfang.github.io/2017/02/25/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/)

在Linux（Unix）中，可用的网络 I/O 模型有五种：**阻塞I/O，非阻塞I/O，I/O多路复用（select/poll），信号驱动I/O，异步I/O**。
> 前4种都是同步的，最后一种才是异步的。

数据操作通常分为输入和输出，在操作系统中，数据的输入可以分为两个过程：1. 等待数据准备好；2. 将准备好的数据从内核拷贝到用户空间。

# 阻塞I/O模型
阻塞I/O模型（Blocking IO）：在进程空间调用 `recvfrom` 系统调用时，应用程序会阻塞并对内核进行上下文切换，直到数据包到达且被复制到应用进程的缓冲区或发生错误时才返回。

# 非阻塞I/O模型
非阻塞I/O模型（Non-Blocking IO）：`recvfrom`从应用层到内核的时候，如果缓冲区没有数据的话，直接返回一个`EWOULDBLOCK`错误，一般都对非阻塞I/O逆序户进行**轮询**检查这个状态，看内核是不是有数据到来。

# I/O复用模型
I/O复用模型（IO Multiplexing）：IO多路复用是把多个I/O阻塞在`select`、`poll`、`epoll`这样的系统调用之上，而没有阻塞在真正的I/O系统调用如`recvfrom`之上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。
> I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。

Linux提供的`select`、`poll`两种系统调用顺序扫描文件描述符 fd 是否处于就绪状态。
Linux还提供了`epoll`这种系统调用是基于事件驱动方式代理顺序扫描，因此性能更高。

# 信号驱动I/O模型
信号驱动I/O模型（Signal Driven IO）：首先开启套接口信号驱动I/O功能，并通过系统调用`sigaction`执行一个信号处理函数（此系统调用立即返回，进程继续工作，是非阻塞地）。当数据就绪时，就为该进程生成一个`SIGIO`信号，通过信号回调通知应用程序调用`recvfrom`来读取数据，并通知主循环函数处理数据。

# 异步I/O模型
异步I/O模型（Asynchronous IO）：告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户进程的缓冲区）通知用户进程。

异步I/O模型和信号驱动I/O模型的区别在于：信号驱动I/O模型是通过内核通知用户进程何时开始一个I/O操作；异步I/O模型是通过内核通知用户进程I/O操作何时已经完成。

**对于操作系统而言，底层是支持异步I/O通信的，只不过很长一段时间Java并没有提供异步I/O通信的类库，直到jdk 1.4提供了 NIO，以及jdk 1.7提供了 NIO 2.0**。